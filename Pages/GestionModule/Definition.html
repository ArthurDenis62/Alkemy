<div>
    <input type="text" id="search-box" placeholder="Rechercher...">
    <button type="button" class="btn-reset" onclick="resetPage()">Réinitialiser</button>
</div>

<div class="definition-container">
    <article class="def mt-2">
        <h1 class="def__Title">Scope (Portée) :</h1><br>
        <p class="def__SubTitle">Passons en revue les termes suivants :</p><br>
        <ul class="def__Para">
            <li>Scope () : fait référence à l'endroit où les variables sont accessibles dans tout le programme et est déterminée par l'endroit et la manière dont elles sont déclarées.</li>
            <li>Blocks () : sont des instructions qui existent entre des accolades {}.</li>
            <li>Global scope () : fait référence au contexte dans lequel les variables sont accessibles à chaque partie du programme.</li>
            <li>Global variables () : sont des variables qui existent dans une portée globale.</li>
            <li>Block scope () : fait référence au contexte dans lequel les variables ne sont accessibles que dans le bloc dans lequel elles sont définies.</li>
            <li>Local variables () : sont des variables qui existent dans la portée du bloc.</li>
            <li>Global namespace () : est l'espace de notre code qui contient des informations à portée mondiale.</li>
            <li>Scope pollution () : se produit lorsque trop de variables existent dans un espace de noms ou que les noms de variables sont réutilisés.</li>
        </ul>
    </article>

    <br><br><br>

    <article class="def">
        <h1 class="def__Title">Array (Tableau) :</h1><br>
        <p class="def__SubTitle">Nous avons appris ces concepts concernant les tableaux :</p><br>
        <ul class="def__Para">
            <li>Les tableaux sont des listes qui stockent des données en JavaScript.</li>
            <li>Les tableaux sont créés avec des parenthèses [].</li>
            <li>Chaque élément à l'intérieur d'un tableau est à une position numérotée, ou index, commençant à 0.</li>
            <li>Nous pouvons accéder à un élément d'un tableau en utilisant son index, avec une syntaxe telle que : myArray[0].</li>
            <li>Nous pouvons également modifier un élément dans un tableau en utilisant son index, avec une syntaxe telle que myArray[0] = 'new string';</li>
            <li>Les tableaux ont une lengthpropriété qui vous permet de voir combien d'éléments se trouvent dans un tableau.</li>
            <li>Les tableaux ont leurs propres méthodes, y compris .push()et .pop(), qui ajoutent et suppriment des éléments d'un tableau, respectivement.</li>
            <li>Les tableaux ont de nombreuses méthodes qui exécutent différentes tâches, telles que .slice()et .shift(), vous pouvez trouver de la documentation sur le site Web <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">Mozilla Developer Network</a>.</li>
            <li>Certaines méthodes intégrées subissent une mutation, ce qui signifie que la méthode modifiera le tableau, tandis que d'autres ne subissent pas de mutation. Vous pouvez toujours consulter la documentation.</li>
            <li>Les variables qui contiennent des tableaux peuvent être déclarées avec letou const. Même lorsqu'ils sont déclarés avec const, les tableaux sont toujours modifiables. Cependant, une variable déclarée avec constne peut pas être réaffectée.</li>
            <li>Les tableaux mutés à l'intérieur d'une fonction conserveront ce changement même en dehors de la fonction.</li>
            <li>Les tableaux peuvent être imbriqués dans d'autres tableaux.</li>
            <li>Pour accéder aux éléments des tableaux imbriqués, chaînez les index en utilisant la notation parenthèses.</li>
        </ul>
    </article>

    <br><br><br>

    <article class="def">
        <h1 class="def__Title">Loops (Boucle) :</h1><br>
        <p class="def__SubTitle">Nous avons appris à écrire du code plus propre avec des boucles.</p><br>
        <ul class="def__Para">
            <li>Les boucles effectuent des actions répétitives afin que nous n'ayons pas à coder ce processus manuellement à chaque fois.</li>
            <li>Comment écrire des boucles for avec une variable d'itérateur qui incrémente ou décrémente</li>
            <li>Comment utiliser une boucle for pour parcourir un tableau</li>
            <li>Une boucle imbriquée for est une boucle à l'intérieur d'une autre boucle</li>
            <li>Les boucles while permettent différents types de conditions d'arrêt</li>
            <li>Les conditions d'arrêt sont cruciales pour éviter les boucles infinies.</li>
            <li>Les boucles do...while exécutent le code au moins une fois - ne vérifiant la condition d'arrêt qu'après la première exécution</li>
            <li>Le mot clé break permet aux programmes de sortir d'une boucle lors de l'exécution de son bloc</li>
        </ul>
    </article>
</div>

<script>
    function searchDefinitions() {
  // Récupérer le texte saisi par l'utilisateur
  var searchTerm = document.getElementById('search-box').value.toLowerCase();
  
  // Récupérer toutes les définitions de la page
  var def = document.getElementsByClassName('def');
  
  // Parcourir toutes les définitions et cacher celles qui ne correspondent pas au texte saisi
  for (var i = 0; i < def.length; i++) {
    var def = def[i];
    if (def.textContent.toLowerCase().indexOf(searchTerm) === -1) {
        def.style.display = 'none';
    } else {
        def.style.display = '';
    }
  }
  
  // Afficher la première définition correspondante
  for (var i = 0; i < def.length; i++) {
    var def = def[i];
    if (def.style.display !== 'none') {
        def.style.order = -1;
      break;
    }
  }
}

document.getElementById('search-box').addEventListener('input', searchDefinitions);

function resetPage() {
  // Réinitialiser le champ de recherche
  document.getElementById('search-box').value = '';
  
  // Réafficher toutes les définitions
  var def = document.getElementsByClassName('def');
  for (var i = 0; i < def.length; i++) {
    def[i].style.display = '';
    def[i].style.order = '';
  }
}

</script>